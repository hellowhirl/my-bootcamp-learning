Object-oriented Programming

OOP: a programming paradigm centered around objects rather than functions
- it's not a language or tool
- supported by Ruby, JavaScript, Python, Java, C#, and more

- Before OOp there was procedural programming (too much interdepency)

- In OOP we combine a group of related variables and functions into a unit - an object with properties and methods

4 pillars of OOP

Encapsulation
- Combine a group of related variables and functions that operate on them into a unit - an object with properties and methods

Abstraction
- hide details and complexity and show only essentials; reduce complexity + isolate impact of changes

Inheritance
- remove redundant code by defining once in a generic object

Polymorphism
- method behaves differently depending on the object we are referencing; refactor ugly case/switch or if/eles statements


Object Literals

- a function member of an object is refered to as a 'method'
- other members are 'properties' which hold values
- every object created like this comes from the built in Object constructor function: function Object() { }
- other built-in constructors in JS like (new String(), new Boolean(), etc.) but we instead use literal versions

 Factory functions

 - if an object has one or more methods that object 'has behavior'


 - every object in JS has a property called 'constructor' - references the function used to create that object


Functions are Objects

- when we look at 'constructor' method for each object in JavaScript we can see the underlying built-in object that was used to create it
Example: String(), Number(), Function(), Array(), Object(), etc.

- takeaway: functionars are objects

HAMMERING THIS POINT HOME:
// Primitives are copied by their Value
// Objects (Reference Types) are copied by their Reference Types 

- in JS we can add properties to objects whenever we need to, which makes JS powerful and easy to work with

- There are 3 ways to enumerate all members in an object:
    for ( in ) loop
    Object.keys()
    'in' operator

- Abstraction: hide the details, show the essentials (like buttons on a DVD player)
- To apply abstraction we need to hide certain members from the outside

About scope and closure:
- scope: determines the accessibility (visibility) of variables.
- closure: when you have a function it is intrinsically tied to the scope of its parent
- when we have nested functions we create a 'scope chain' - and the variable that is closest to its own scope will be returned
- variables within a function are created each time new and die whem the function ends
- scope is temporary and it dies whereas closure stays there
- a closure determines what variables will be accessible to an inner function


Explain difference between scope and closure


Classical Inheritance:
- allows an object to take on the properties and methods of another object - makes it easy to reuse code in another part of the application

Typically classes are examplained as below structure:

Base/Super/Parent Class
SHAPE
CIRCLE SQUARE
Derived/Sub/Child Class

IS-A relationship

CIRCLE is a SHAPE


Prototypes and Prototypical Inheritance
- whenever we hear 'prototype', just think of 'parent'
- a prototype is a parent object of another object, refered to as JS engine walks up the prototype chain, starting from itself
- it will refer to the first member (property or method) it finds, starting at the bottom going all the way up to the root object

'__proto__' has been deprecated and should only be used for troubleshooting problems (never used in our code)

- the root object in JS doesn't have a prototype (parent)


Multilevel inheritance

example with Array object:

______________
| objectBase | original methods like toString(), .hasOwnProperty(), etc.
``````````````
      ▲
_____________
| arrayBase | methods like .push(), .splice(), .shift(), etc.
`````````````
      ▲
 ___________
 | myArray | any methods or properties we define in this object
 ```````````



example with objects that have custom constructors:

______________
| objectBase | original methods like toString(), .hasOwnProperty(), etc.
``````````````
      ▲
______________
| circleBase | properties and methods we defined like radius and draw()
``````````````
      ▲
  __________
  | circle | created after we did 'const circle = new Circle();' - our custom constructor() sets prototype to circleBase
  ``````````

In summary: Objects created by a given constructor will have the same prototype.


by default below properties are set to true:

writable: able to set value or not (false will make it a read-only property)
enumerable: members of object will show up for Object.keys() or not
configurable: able to delete property or not

- constructors also have a 'prototype' property
- .__proto__ and .prototype return the same result

IN SUMMARY:
- when navigating through an object in JS, don't go deeper than what's inside a constructor

Prototype vs Instance members
- we can reference (or call) instance methods from a prototype member
- we can reference (or call) prototype methods from an instance member


WE SHOULD NOT MODIFY (BUILT-IN) OBJECTS THAT WE DON'T OWN IN JAVASCRIPT
OTHER LIBRARIES MY DEPEND ON THESE BUILT-IN OBJECTS
- don't overwrite methods
- don't add new methods/properties
- don't remove existing methods/properties
❌Array.prototype.shuffle = function() { // ..}

- Our objcts should always be in a valid state (reliable and trustworthy) - that's why we use abstraction
PREMATURE OPTIMIZATION IS THE ROOT OF ALL EVIL

Method overriding: 
- override a method that is defined in the base object (reimplementing a method in a child object)

Polymorphism (poly: many, morph: form)

- Don't overuse Inerhitanc - it can make your code complex and fragile
- There is another technique for code reuse called "Composition"

AVOID CREATING INHERITANCE HIERARCHIES - DO NOT GO ABOVE ONE LEVEL

FAVOR COMPOSITION OVER INHERITANCE

- Composition is achieved with Mixins