// React notes

// Each component is a piece of UI - build them separately and put together to build complex UI'separately
// React elements are just JS objects that maps to a DOM elements (just represents DOM elememnt in memory)

// Don't need to write code to query and manipulate DOM or attach event handlers to DOM elements


// Both below are similar in component based architecture;
// Angular is a complete solution framework
// Reach is simply a library that handles the View - making sure view is in sync with the state

// create-react-app
// installs Web Development Server, Webpack, Babel
// zero config setup - but possible with running command
    $ npm run eject

// JSX: JavaScript XML
// Babel converts JSX code to browser readable JavaScript

Helpful plugins
- Prettier
- Simple React Snippets
    shortcuts like: imrc, cc
- Code Runner
- Auto Import - ES6, TS, JSX
- File utils
- Live Server

// id="root" is container for our React app

- react-scripts:

"start": "react-scripts start", // start dev server 
    $ npm start
"build": "react-scripts build", // build application for production for optimized pacckage
"test": "react-scripts test", // for running unit tests
"eject": "react-scripts eject" // eject from create-react app and customize configs for this project

- all the complex configs (babel, webpack, etc.) are hidden

*only use if you know what you're doing*
    $ npm run eject
- this will make all dependencies visible and you can also see 'config' folder


- Full-stack: JavaScript / Node + Express + MongoDB

- better to use .jsx for file names in 'components' - we get better code completion

Simple React Snippets
- imrc: import React / Component
- cc: Class Coomponent

Setting attribute:
<img src={this.state.imageUrl} alt="" />

we can't use 'class' because it's a reserved keyword in JS, so we use 'className' in JSX

refactor shortcut in VS code : CTRL + SHIFT + R

alias for npm install
    $ npm i

- when we build an application webpack will pull in files that we have specified on index.js with 'import' and put them in a final bundle


- real world applications consist of a "tree of components"

Zen coding with Emmet: create table with class "container" with <thead> enclosing <tr> enclosing 4 <td> tags
table.container>thead>tr>td*4


Correct vs Incorrect ES6 syntax:

{this.state.counters.map(c => (
    <Counter key={c.id} />
))}

{this.state.counters.map(c => {
    <Counter key={c.id} />;
})}


- In developer tools '$0' indicates the latest element we have selected in dev tools
- For example, on <button> we can use $0.click() and activate the button 

Props vs State

- props is data that we give to a component - eg. input to component like value={counter.value} - cannot access the state of other component
    - props is read-only: we cannot change input to component inside of the component
    Cannot do this code within a component:
        this.props.value = 0;
        (will get error: "Cannot assign to read only property 'value' of object '#<Object>')
        - instead we should use state and 'setState' creating method within the life cycle of the component

- state is data that is local (private) to a component (not accessible to other components)
    - sometimes a component will not have a state, it may get all of its data through props

- "The component that owns a piece of the state, should be the one modifying it"

- The whole point of using objects is to encapsulate related values

Local state is different from outside components problem:
- Single source of truth: remove the local state in the child component and have a single source of truth
- if we don't have a single source of truth, state can be changed but it won't be reflected in the DOM
- each component have their own local state - so values are disconnected


- Controlled Componnet: has no local state but receives data via props and raises events when data needs to be changed - it is entirely controlled by its parent

Keeping multple components in sync:
- "lift the state up": when there is no parent/child relationship between 2 componenets and you want to share data between them
- if we lift state up to <App /> then it can be parent to other child components, then state can be passed using props

Lifting the state up:
- lifted up state from counters componenet to its parent (App componenet) - now we can share state with chilren of this component via props, and with this technique now we have multiple componenets in sync

Stateless Functional Components:
- Zen coding shortcut: sfc

- for classes that have a single method (like return()) and no state we can convert into a Stateless Functional Component
- simply define a function that returns a React element (instead of using class that extends Component class with render method

Lifecycle Hooks* (below are used 90% of time)

== MOUNT ==
constructor
render
componentDidMount - App gets mounted and goes into DOM

== UPDATE ==
render
componentDidUpdate - used for if we want to make ajax call to get new data based on changes to state and props objects

== UNMOUNT ==
componentWillUnmount - gives us opportunity to do clean up (timers and listeneres) and prevent memory leaks

* cannot use lifecycle hooks in stateless functional components - they can only be used with class components

- when a component is rendered we get a React element which updates virtual DOM - so we have 2 object references in memory for old virtual DOM and new virtual DOM, then React will update DOM based on the difference only

- when writing code, go step by step. Write a little bit of code, test to see if it works, then move on. Don't go for "big moves"


Steps for when building a new component:
1) Determine interface with inputs and/or events


folders in React project:
"common": components that can be used across other projects
"utils": utility classes and functions

- in order to chain methods in lodash we need to convert array into lodash wrapper

VS Code shortcut:
command + P and type '@': look at members of a class, and search from that


levels of components:

high level: simplified, abstract
low level: detailed, elements

symetry/consistency is when high level or low level components are grouped together - should be same level of abstraction

object destructuring should be done at the beginning of everyt functional component



React Router

- to add routing to our project we need to use following command

npm i react-router-dom

<Route> component looks at the current URL and if it matches 'path' attribute then it will return the component that is in the 'component' attribute - these attributes are passed as props

props wrapped with a Route component:
- history: to work with history object in the browser - with this we can send user to a different page
- location: represents where app is at now
- match: contains info about about how URL matches path we set in our route

How to pass/retrieve route parameters
- to define a parameter we should prefix that parameter with a colon
- fetch from 'match.params'

- when we define parameters in our route by detault those parameters are required
- to make then not required we append a '?'

- programmatic navigation: 

- nested routing: for example routing on top and bottom

Zen coding trick:
    Route[path][component]*4
    form>(div.form-group>label+input.form-control)*2

Shortcut to tab through all methods in a component
    SHIFT + CMD + >

Shortcut from command palette (SHIFT + CMD + P)
    Wrap with abbreviation (to surround selected text with a tag - also possible to do zen coding)

Shortcut for editing multiple places in VS Code:
    Hold ALT while selecting different places

In React we should never work with the 'document' object - we are abstracting from it
- also it makes our applications easier to maintain and unit test

onChange event: 
occurs when the value of an element has been changed.

currentTarget event property: 
returns the element whose event listeners triggered the event.

- When building a form we should set initialize the properties of state objects to empty string '' or some value from the server, otherwise we'll get an error

VS code shortcut - Select all occurences
CMD + SHIFT + L

VS code shortcut - indenting line
CMD + { OR }